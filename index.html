<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Gor by buger</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Gor</h1>
      <h2 class="project-tagline">Gor is an open-source tool for capturing and replaying live HTTP traffic into a test environment in order to continuously test your system with real data. It can be used to increase confidence in code deployments, configuration changes and infrastructure changes.</h2>
      <a href="https://github.com/buger/gor" class="btn">View on GitHub</a>
      <a href="https://github.com/buger/gor/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/buger/gor/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="about" class="anchor" href="#about" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>About</h2>

<p>Gor is an open-source tool for capturing and replaying live HTTP traffic into a test environment in order to continuously test your system with real data. It can be used to increase confidence in code deployments, configuration changes and infrastructure changes.</p>

<p>Now you can test your code on real user sessions in an automated and repeatable fashion.
<strong>No more falling down in production!</strong></p>

<p>Here is basic workflow: The listener server catches http traffic and sends it to the replay server or saves to file. The replay server forwards traffic to a given address.</p>

<p><img src="http://i.imgur.com/9mqj2SK.png" alt="Diagram"></p>

<h2>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Examples</h2>

<h3>
<a id="capture-traffic-from-port" class="anchor" href="#capture-traffic-from-port" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Capture traffic from port</h3>

<div class="highlight highlight-source-shell"><pre><span class="pl-c"># Run on servers where you want to catch traffic. You can run it on each `web` machine.</span>
sudo gor --input-raw :80 --output-tcp replay.<span class="pl-k">local</span>:28020

<span class="pl-c"># Replay server (replay.local).</span>
gor --input-tcp replay.<span class="pl-k">local</span>:28020 --output-http http://staging.com</pre></div>

<p>Since Gor use raw sockets to capture traffic it require <code>sudo</code> access. Alternatively you can allow access to raw sockets like this: <code>sudo setcap CAP_NET_RAW=ep gor</code></p>

<h3>
<a id="using-1-gor-instance-for-both-listening-and-replaying" class="anchor" href="#using-1-gor-instance-for-both-listening-and-replaying" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using 1 Gor instance for both listening and replaying</h3>

<p>It's recommended to use separate server for replaying traffic, but if you have enough CPU resources you can use single Gor instance.</p>

<pre><code>sudo gor --input-raw :80 --output-http "http://staging.com"
</code></pre>

<h3>
<a id="guarantee-of-replay-and-http-input" class="anchor" href="#guarantee-of-replay-and-http-input" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Guarantee of replay and HTTP input</h3>

<p>Due to how traffic interception works, there is chance of missing requests. If you want guarantee that requests will be replayed you can use http input, but it will require changes in your app as well. </p>

<pre><code>sudo gor --input-http :28019 --output-http "http://staging.com"
</code></pre>

<p>Then in your application you should send copy (e.g. like reverse proxy) all incoming requests to Gor http input. </p>

<h2>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h2>

<h3>
<a id="forward-to-multiple-addresses" class="anchor" href="#forward-to-multiple-addresses" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Forward to multiple addresses</h3>

<p>You can forward traffic to multiple endpoints. Just add multiple --output-* arguments.</p>

<pre><code>gor --input-tcp :28020 --output-http "http://staging.com"  --output-http "http://dev.com"
</code></pre>

<h4>
<a id="splitting-traffic" class="anchor" href="#splitting-traffic" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Splitting traffic</h4>

<p>By default it will send same traffic to all outputs, but you have options to equally split it:</p>

<pre><code>gor --input-tcp :28020 --output-http "http://staging.com"  --output-http "http://dev.com" --split-output true
</code></pre>

<h3>
<a id="http-output-workers" class="anchor" href="#http-output-workers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>HTTP output workers</h3>

<p>By default Gor creates a dynamic pool of workers: it starts with 10 and creates more http output workers when the http output queue length is greater than 10.  The number of workers created (N) is equal to the queue length at the time which it is checked and found to have a length greater than 10. The queue length is checked every time a message is written to the http output queue.  No more workers will be spawned until that request to spawn N workers is satisfied.  If a dynamic worker cannot process a message at that time, it will sleep for 100 milliseconds. If a dynamic worker cannot process a message for 2 seconds it dies.
You may specify fixed number of workers using  <code>--output-http-workers=20</code> option.</p>

<h3>
<a id="follow-redirects" class="anchor" href="#follow-redirects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Follow redirects</h3>

<p>By default Gor will ignore all redirects since they are handled by clients using your app, but in scenarios where your replayed environment introduces new redirects, you can enable them like this: </p>

<pre><code>gor --input-tcp replay.local:28020 --output-http http://staging.com --output-http-redirects 2
</code></pre>

<p>The given example will follow up to 2 redirects per request.</p>

<h3>
<a id="http-timeouts" class="anchor" href="#http-timeouts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>HTTP timeouts</h3>

<p>By default http timeout for both request and response is 5 seconds. You can override it like this:</p>

<pre><code>gor --input-tcp replay.local:28020 --output-http http://staging.com --output-http-timeout 30s
</code></pre>

<h3>
<a id="rate-limiting" class="anchor" href="#rate-limiting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rate limiting</h3>

<p>Rate limiting can be useful if you only want to forward parts of production traffic and not overload your staging environment. There are 2 strategies: dropping random requests or dropping fractions of requests based on Header or URL param value. </p>

<h4>
<a id="dropping-random-requests" class="anchor" href="#dropping-random-requests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dropping random requests</h4>

<p>Every input and output supports random rate limiting.
There are 2 limiting algorithms: absolute or percentage based. </p>

<p>Absolute: If for current second it reached specified requests limit - disregard the rest, on next second counter reseted.</p>

<p>Percentage: For input-file it will slowdown or speedup request execution, for the rest it will use random generator to decide if request pass or not based on chance you specified. </p>

<p>You can specify your desired limit using the
"|" operator after the server address:</p>

<h4>
<a id="limiting-replay-using-absolute-number" class="anchor" href="#limiting-replay-using-absolute-number" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Limiting replay using absolute number</h4>

<pre><code># staging.server will not get more than 10 requests per second
gor --input-tcp :28020 --output-http "http://staging.com|10"
</code></pre>

<h4>
<a id="limiting-listener-using-percentage-based-limiter" class="anchor" href="#limiting-listener-using-percentage-based-limiter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Limiting listener using percentage based limiter</h4>

<pre><code># replay server will not get more than 10% of requests 
# useful for high-load environments
gor --input-raw :80 --output-tcp "replay.local:28020|10%"
</code></pre>

<h4>
<a id="limiting-based-on-header-or-url-param-value" class="anchor" href="#limiting-based-on-header-or-url-param-value" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Limiting based on Header or URL param value</h4>

<p>If you have unique user id (like API key) stored in header or URL you can consistently forward specified percent of traffic only for fraction of this users. 
Basic formula looks like this: <code>FNV32-1A_hashing(value) % 100 &gt;= chance</code>. Examples:</p>

<pre><code># Limit based on header value
gor --input-raw :80 --output-tcp "replay.local:28020|10%" --http-header-limiter "X-API-KEY: 10%"

# Limit based on header value
gor --input-raw :80 --output-tcp "replay.local:28020|10%" --http-param-limiter "api_key: 10%"
</code></pre>

<p>Only percentage based limiting supported.</p>

<h3>
<a id="filtering" class="anchor" href="#filtering" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Filtering</h3>

<h4>
<a id="allow-url-regexp" class="anchor" href="#allow-url-regexp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Allow url regexp</h4>

<pre><code># only forward requests being sent to the /api endpoint
gor --input-raw :8080 --output-http staging.com --http-allow-url /api
</code></pre>

<h4>
<a id="disallow-url-regexp" class="anchor" href="#disallow-url-regexp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Disallow url regexp</h4>

<pre><code># only forward requests NOT being sent to the /api... endpoint
gor --input-raw :8080 --output-http staging.com --http-disallow-url /api
</code></pre>

<h4>
<a id="filter-based-on-regexp-of-header" class="anchor" href="#filter-based-on-regexp-of-header" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Filter based on regexp of header</h4>

<pre><code># only forward requests with an api version of 1.0x
gor --input-raw :8080 --output-http staging.com --http-allow-header api-version:^1\.0\d

# only forward requests NOT containing User-Agent header value "Replayed by Gor"
gor --input-raw :8080 --output-http staging.com --http-disallow-header "User-Agent: Replayed by Gor"
</code></pre>

<h4>
<a id="filter-based-on-http-method" class="anchor" href="#filter-based-on-http-method" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Filter based on http method</h4>

<p>Requests not matching a specified whitelist can be filtered out. For example to strip non-nullipotent requests:</p>

<pre><code>gor --input-raw :80 --output-http "http://staging.server" \
    --http-allow-method GET \
    --http-allow-method OPTIONS
</code></pre>

<h3>
<a id="rewriting-original-request" class="anchor" href="#rewriting-original-request" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rewriting original request</h3>

<p>Gor supports some basic request rewriting support. For complex logic you can use middleware, see below.</p>

<h4>
<a id="rewrite-url-based-on-a-mapping" class="anchor" href="#rewrite-url-based-on-a-mapping" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rewrite URL based on a mapping</h4>

<pre><code># rewrite url to match the following
gor --input-raw :8080 --output-http staging.com --http-rewrite-url /v1/user/([^\\/]+)/ping:/v2/user/$1/ping
</code></pre>

<h4>
<a id="set-url-param" class="anchor" href="#set-url-param" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Set URL param</h4>

<p>Set request url param, if param already exists it will be overwritten</p>

<pre><code>gor --input-raw :8080 --output-http staging.com --http-set-param api_key=1
</code></pre>

<h4>
<a id="set-header" class="anchor" href="#set-header" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Set Header</h4>

<p>Set request header, if header already exists it will be overwritten. This may be useful if you need to identify requests generated by Gor or enable feature flagged functionality in an application:</p>

<pre><code>gor --input-raw :80 --output-http "http://staging.server" \
    --http-header "User-Agent: Replayed by Gor" \
    --http-header "Enable-Feature-X: true"
</code></pre>

<h4>
<a id="host-header" class="anchor" href="#host-header" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Host header</h4>

<p>Host header gets special treatment. By default Host get set to the value specified in --output-http. If you manually set --http-header "Host: anonther.com", Gor will not override Host value.</p>

<p>If you app accepts traffic from multiple domain, and you want to keep original headers, there is specific <code>--http-original-host</code> with tells Gor do not touch Host header at all.</p>

<h3>
<a id="middleware" class="anchor" href="#middleware" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Middleware</h3>

<p>Middleware is a program that accepts request and response payload at STDIN and emits modified requests at STDOUT. You can implement any custom logic like stripping private data, advanced rewriting, support for oAuth and etc.</p>

<pre><code>                   Original request      +--------------+
+-------------+----------STDIN----------&gt;+              |
|  Gor input  |                          |  Middleware  |
+-------------+----------STDIN----------&gt;+              |
                   Original response     +------+---+---+
                                                |   ^
+-------------+    Modified request             v   |
| Gor output  +&lt;---------STDOUT-----------------+   |
+-----+-------+                                     |
      |                                             |
      |            Replayed response                |
      +------------------STDIN-----------------&gt;----+
</code></pre>

<p>Middleware can be written in any language, see <code>examples/middleware</code> folder for examples.
Middleware program should accept the fact that all communication with Gor is asynchronous, there is no guarantee that original request and response messages will come one after each other. Your app should take care of the state if logic depends on original or replayed response, see <code>examples/middleware/token_modifier.go</code> as example.</p>

<p>Simple bash echo middleware (returns same request) will look like this:</p>

<div class="highlight highlight-source-shell"><pre><span class="pl-k">while</span> <span class="pl-c1">read</span> line<span class="pl-k">;</span> <span class="pl-k">do</span>
  <span class="pl-c1">echo</span> <span class="pl-smi">$line</span>
end</pre></div>

<p>Middleware can be enabled using <code>--middleware</code> option, by specifying path to executable file:</p>

<pre><code>gor --input-raw :80 --middleware "/opt/middleware_executable" --output-http "http://staging.server"
</code></pre>

<h4>
<a id="communication-protocol" class="anchor" href="#communication-protocol" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Communication protocol</h4>

<p>All messages should be hex encoded, new line character specifieds the end of the message, eg. new message per line.</p>

<p>Decoded payload consist of 2 parts: header and HTTP payload, separated by new line character.  </p>

<p>Example request payload:</p>

<pre><code>1 932079936fa4306fc308d67588178d17d823647c 1439818823587396305
GET /a HTTP/1.1
Host: 127.0.0.1

</code></pre>

<p>Example response payload:</p>

<pre><code>2 8e091765ae902fef8a2b7d9dd960e9d52222bd8c 2782013
HTTP/1.1 200 OK
Date: Mon, 17 Aug 2015 13:40:23 GMT
Content-Length: 0
Content-Type: text/plain; charset=utf-8

</code></pre>

<p>Header contains request meta information separated by spaces. First value is payload type, possible values: <code>1</code> - request, <code>2</code> - original response, <code>3</code> - replayed response.
Next goes request id: unique among all requests (sha1 of time and Ack), but remain same for original and replayed response, so you can create associations between request and responses. Third argument varies depending on payload type: for request - start time, for responses - round-trip time.</p>

<p>HTTP payload is unmodified HTTP requests/responses intercepted from network. You can read more about request format <a href="http://www.jmarshall.com/easy/http/">here</a>, <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">here</a> and <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">here</a>. You can operate with payload as you want, add headers, change path, and etc. Basically you just editing a string, just ensure that it is RCF compliant.</p>

<p>At the end modified (or untouched) request should be emitted back to STDOUT, keeping original header, and hex-encoded. If you want to filter request, just not send it. Emitting responses back is required, even if you did not touch them.</p>

<h4>
<a id="advanced-example" class="anchor" href="#advanced-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Advanced example</h4>

<p>Imagine that you have auth system that randomly generate access tokens, which used later for accessing secure content. Since there is no pre-defined token value, naive approach without middleware (or if middleware use only request payloads) will fail, because replayed server have own tokens, not synced with origin. To fix this, our middleware should take in account responses of replayed and origin server, store <code>originalToken -&gt; replayedToken</code> aliases and rewrite all requests using this token to use replayed alias. See <code>examples/middleware/token_modifier.go</code> and <code>middleware_test.go#TestTokenMiddleware</code> as example of described scheme.</p>

<h3>
<a id="saving-requests-to-file-and-replaying-them" class="anchor" href="#saving-requests-to-file-and-replaying-them" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Saving requests to file and replaying them</h3>

<p>You can save requests to file, and replay them later:</p>

<pre><code># write to file
gor --input-raw :80 --output-file requests.gor

# read from file
gor --input-file requests.gor --output-http "http://staging.com"
</code></pre>

<p><strong>Note:</strong> Replay will preserve the original time differences between requests.</p>

<h3>
<a id="load-testing" class="anchor" href="#load-testing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Load testing</h3>

<p>Currently it supported only by <code>input-file</code> and only when using percentage based limiter. Unlike default limiter for <code>input-file</code> instead of dropping requests it will slowdown or speedup request emitting. Note that unlike examples above limiter is applied to input:</p>

<pre><code># Replay from file on 2x speed 
gor --input-file "requests.gor|200%" --output-http "staging.com"
</code></pre>

<h3>
<a id="basic-auth" class="anchor" href="#basic-auth" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Basic Auth</h3>

<p>If your development or staging environment is protected by Basic Authentication then those credentials can be injected in during the replay:</p>

<pre><code>gor --input-raw :80 --output-http "http://user:pass@staging .com"
</code></pre>

<p>Note: This will overwrite any Authorization headers in the original request.</p>

<h2>
<a id="stats" class="anchor" href="#stats" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Stats</h2>

<p>Gor can report stats on the <code>output-tcp</code> and <code>output-http</code> request queues. Stats are reported to the console every 5 seconds in the form <code>latest,mean,max,count,count/second</code> by using the <code>--output-http-stats</code> and <code>--output-tcp-stats</code> options.</p>

<p>Examples:</p>

<pre><code>2014/04/23 21:17:50 output_tcp:latest,mean,max,count,count/second
2014/04/23 21:17:50 output_tcp:0,0,0,0,0
2014/04/23 21:17:55 output_tcp:1,1,2,68,13
2014/04/23 21:18:00 output_tcp:1,1,2,92,18
2014/04/23 21:18:05 output_tcp:1,1,2,119,23
</code></pre>

<pre><code>Version: 0.8
2014/04/23 21:19:46 output_http:latest,mean,max,count,count/second
2014/04/23 21:19:46 output_http:0,0,0,0,0
2014/04/23 21:19:51 output_http:0,0,0,0,0
2014/04/23 21:19:56 output_http:0,0,0,0,0
2014/04/23 21:20:01 output_http:1,0,1,50,10
2014/04/23 21:20:06 output_http:1,1,4,72,14
2014/04/23 21:20:11 output_http:1,0,1,179,35
2014/04/23 21:20:16 output_http:1,0,1,148,29
2014/04/23 21:20:21 output_http:1,1,2,91,18
2014/04/23 21:20:26 output_http:1,1,2,150,30
2014/04/23 21:18:15 output_http:100,99,100,70,14
2014/04/23 21:18:21 output_http:100,99,100,55,11
</code></pre>

<h3>
<a id="how-can-i-tell-if-i-have-bottlenecks" class="anchor" href="#how-can-i-tell-if-i-have-bottlenecks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How can I tell if I have bottlenecks?</h3>

<p>Key areas that sometimes experience bottlenecks are the output-tcp and output-http functions which have internal queues for requests. Each queue has an upper limit of 100. Enable stats reporting to see if any queues are experiencing bottleneck behavior.</p>

<h4>
<a id="output-http-bottlenecks" class="anchor" href="#output-http-bottlenecks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>output-http bottlenecks</h4>

<p>When running a Gor replay the output-http feature may bottleneck if:</p>

<ul>
<li>the replay has inadequate bandwidth. If the replay is receiving or sending more messages than its network adapter can handle the output-http-stats  may report that the output-http queue is filling up. See if there is a way to upgrade the replay's bandwidth.</li>
<li>with <code>--output-http-workers</code> set to anything other than <code>-1</code> the <code>-output-http</code> target is unable to respond to messages in a timely manner. The http output workers which take messages off the output-http queue, process the request, and ensure that the request did not result in an error may not be able to keep up with the number of incoming requests. If the replay is not using dynamic worker scaling (<code>--output-http-workers=-1</code>)  The optimal number of output-http-workers can be determined with the formula <code>output-workers = (Average number of requests per second)/(Average target response time per second)</code>.</li>
</ul>

<h4>
<a id="output-tcp-bottlenecks" class="anchor" href="#output-tcp-bottlenecks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>output-tcp bottlenecks</h4>

<p>When using the Gor listener the output-tcp feature may bottleneck if:</p>

<ul>
<li>the replay is unable to accept and process more requests than the listener is able generate. Prior to troubleshooting the output-tcp bottleneck, ensure that the replay target is not experiencing any bottlenecks. </li>
<li>the replay target has inadequate bandwidth to handle all its incoming requests.  If a replay target's incoming bandwidth is maxed out the output-tcp-stats may report that the output-tcp queue is filling up. See if there is a way to upgrade the replay's bandwidth.</li>
</ul>

<h3>
<a id="elasticsearch" class="anchor" href="#elasticsearch" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ElasticSearch</h3>

<p>For deep response analyze based on url, cookie, user-agent and etc. you can export response metadata to ElasticSearch. See <a href="ELASTICSEARCH.md">ELASTICSEARCH.md</a> for more details.</p>

<pre><code>gor --input-tcp :80 --output-http "http://staging.com" --output-http-elasticsearch "es_host:api_port/index_name"
</code></pre>

<h2>
<a id="additional-help" class="anchor" href="#additional-help" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Additional help</h2>

<p>Feel free to ask question directly by email or by creating github issue.</p>

<h2>
<a id="latest-releases-including-binaries" class="anchor" href="#latest-releases-including-binaries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Latest releases (including binaries)</h2>

<p><a href="https://github.com/buger/gor/releases">https://github.com/buger/gor/releases</a></p>

<h2>
<a id="command-line-reference" class="anchor" href="#command-line-reference" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Command line reference</h2>

<p><code>gor -h</code> output:</p>

<pre><code>  -http-allow-header=[]: A regexp to match a specific header against. Requests with non-matching headers will be dropped:
   gor --input-raw :8080 --output-http staging.com --http-allow-header api-version:^v1
  -http-disallow-header=[]: A regexp to match a specific header against. Requests with matching headers will be dropped:
   gor --input-raw :8080 --output-http staging.com --http-disallow-header "User-Agent: Replayed by Gor"
  -http-allow-method=[]: Whitelist of HTTP methods to replay. Anything else will be dropped:
  gor --input-raw :8080 --output-http staging.com --http-allow-method GET --http-allow-method OPTIONS
  -http-allow-url=[]: A regexp to match requests against. Filter get matched agains full url with domain. Anything else will be dropped:
   gor --input-raw :8080 --output-http staging.com --http-allow-url ^www.
  -http-disallow-url=[]: A regexp to match requests against. Filter get matched agains full url with domain. Anything else will be forwarded:
   gor --input-raw :8080 --output-http staging.com --http-disallow-url ^www.
  -http-header-limiter=[]: Takes a fraction of requests, consistently taking or rejecting a request based on the FNV32-1A hash of a specific header:
   gor --input-raw :8080 --output-http staging.com --http-header-imiter user-id:25%
  -http-param-limiter=[]: Takes a fraction of requests, consistently taking or rejecting a request based on the FNV32-1A hash of a specific GET param:
   gor --input-raw :8080 --output-http staging.com --http-param-limiter user_id:25%
  -http-rewrite-url=[]: Rewrite the request url based on a mapping:
  gor --input-raw :8080 --output-http staging.com --http-rewrite-url /v1/user/([^\/]+)/ping:/v2/user/$1/ping
  -http-set-header=[]: Inject additional headers to http reqest:
  gor --input-raw :8080 --output-http staging.com --http-set-header 'User-Agent: Gor'
  -http-set-param=[]: Set request url param, if param already exists it will be overwritten:
  gor --input-raw :8080 --output-http staging.com --http-set-param api_key=1
  -input-dummy=[]: Used for testing outputs. Emits 'Get /' request every 1s
  -input-file=[]: Read requests from file:
  gor --input-file ./requests.gor --output-http staging.com
  -input-http=[]: Read requests from HTTP, should be explicitly sent from your application:
  # Listen for http on 9000
  gor --input-http :9000 --output-http staging.com
  -input-raw=[]: Capture traffic from given port (use RAW sockets and require *sudo* access):
  # Capture traffic from 8080 port
  gor --input-raw :8080 --output-http staging.com
  -input-tcp=[]: Used for internal communication between Gor instances. Example:
  # Receive requests from other Gor instances on 28020 port, and redirect output to staging
  gor --input-tcp :28020 --output-http staging.com
  -memprofile="": write memory profile to this file
  -output-dummy=[]: Used for testing inputs. Just prints data coming from inputs.
  -output-file=[]: Write incoming requests to file:
  gor --input-raw :80 --output-file ./requests.gor
  -output-http=[]: Forwards incoming requests to given http address.
  # Redirect all incoming requests to staging.com address
  gor --input-raw :80 --output-http http://staging.com
  -output-http-elasticsearch="": Send request and response stats to ElasticSearch:
  gor --input-raw :8080 --output-http staging.com --output-http-elasticsearch 'es_host:api_port/index_name'
  -output-http-header-filter=[]: WARNING: `--output-http-header-filter` DEPRECATED, use `--http-allow-header` instead
  -output-http-redirects=0: Enable how often redirects should be followed.
  -output-http-stats=false: Report http output queue stats to console every 5 seconds. Remember to include also `--stats`
  -output-http-workers=0: Gor uses dynamic worker scaling by default.  Enter a number to run a set number of workers.
  -output-tcp=[]: Used for internal communication between Gor instances. Example:
  # Listen for requests on 80 port and forward them to other Gor instance on 28020 port
  gor --input-raw :80 --output-tcp replay.local:28020
  -output-tcp-stats=false: Report TCP output queue stats to console every 5 seconds. Remember to include also `--stats`
  -split-output=false: By default each output gets same traffic. If set to `true` it splits traffic equally among all outputs.
  -stats=false: Turn on queue stats output. Use in combination with the other *-stats flags.
  -verbose=false: Turn on verbose/debug output
</code></pre>

<h2>
<a id="building-from-source" class="anchor" href="#building-from-source" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building from source</h2>

<ol>
<li>Setup standard Go environment <a href="http://golang.org/doc/code.html">http://golang.org/doc/code.html</a> and ensure that $GOPATH environment variable properly set.</li>
<li>
<code>go get github.com/buger/gor</code>.</li>
<li><code>cd $GOPATH/src/github.com/buger/gor</code></li>
<li>
<code>go build</code> to get binary, or <code>go test</code> to run tests</li>
</ol>

<h2>
<a id="development" class="anchor" href="#development" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Development</h2>

<p>Project contains Docker environment.</p>

<ol>
<li>Build container: <code>make dbuild</code>
</li>
<li>Run all tests: <code>make dtest</code>. Run specific test: <code>make dtest ARGS=-test.run=**regexp**</code>
</li>
<li>Bash access to container: <code>make dbash</code>. Inside container you have python to run simple web server <code>python -m SimpleHTTPServer 8080</code> and <code>curl</code> to make http requests. </li>
</ol>

<h2>
<a id="questions-and-support" class="anchor" href="#questions-and-support" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Questions and support</h2>

<p>All bug-reports and suggestions should go though Github Issues or our <a href="https://groups.google.com/forum/#!forum/gor-users">Google Group</a>. Or you can just send email to <a href="mailto:gor-users@googlegroups.com">gor-users@googlegroups.com</a></p>

<p>If you have some private questions you can send direct mail to <a href="mailto:leonsbox@gmail.com">leonsbox@gmail.com</a></p>

<h2>
<a id="faq" class="anchor" href="#faq" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FAQ</h2>

<h3>
<a id="what-os-are-supported" class="anchor" href="#what-os-are-supported" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What OS are supported?</h3>

<p>For now only Linux based. *BSD (including MacOS is not supported yet, check <a href="https://github.com/buger/gor/issues/22">https://github.com/buger/gor/issues/22</a> for details)</p>

<h3>
<a id="why-does-the---input-raw-requires-sudo-or-root-access" class="anchor" href="#why-does-the---input-raw-requires-sudo-or-root-access" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Why does the <code>--input-raw</code> requires sudo or root access?</h3>

<p>Listener works by sniffing traffic from a given port. It's accessible
only by using sudo or root access.</p>

<h3>
<a id="how-do-you-deal-with-user-session-to-replay-the-traffic-correctly" class="anchor" href="#how-do-you-deal-with-user-session-to-replay-the-traffic-correctly" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How do you deal with user session to replay the traffic correctly?</h3>

<p>You can rewrite session related headers/params to match your staging environment. If you require custom logic (e.g random token based auth) follow this discussion: <a href="https://github.com/buger/gor/issues/154">https://github.com/buger/gor/issues/154</a></p>

<h3>
<a id="can-i-use-gor-to-intercept-ssl-traffic" class="anchor" href="#can-i-use-gor-to-intercept-ssl-traffic" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Can i use Gor to intercept SSL traffic?</h3>

<p>Basic idea is that SSL was made to protect itself from traffic interception. There 2 options: 
1. Move SSL handling to proxy like Nginx or Amazon ELB. And allow Gor to listen on upstreams. 
2. Use <code>--input-http</code> so you can duplicate request payload directly from your app to Gor, but it will require your app modifications.</p>

<p>More can be find here: <a href="https://github.com/buger/gor/issues/85">https://github.com/buger/gor/issues/85</a></p>

<h3>
<a id="is-there-a-limit-for-size-of-http-request-when-using-output-http" class="anchor" href="#is-there-a-limit-for-size-of-http-request-when-using-output-http" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Is there a limit for size of HTTP request when using output-http?</h3>

<p>Due to the fact that Gor can't guarantee interception of all packets, for large payloads &gt; 200kb there is chance of missing some packets and corrupting body. Treat it as a feature and chance to test broken bodies handling :)
The only way to guarantee delivery is using <code>--input-http</code>, but you will miss some features.</p>

<h3>
<a id="im-getting-too-many-open-files-error" class="anchor" href="#im-getting-too-many-open-files-error" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>I'm getting 'too many open files' error</h3>

<p>Typical linux shell has a small open files soft limit at 1024. You can easily raise that when you do this before starting your gor replay process:</p>

<p>ulimit -n 64000</p>

<p>More about ulimit: <a href="http://www.thecodingmachine.com/solving-the-too-many-open-files-exception-in-red5-or-any-other-application/">http://www.thecodingmachine.com/solving-the-too-many-open-files-exception-in-red5-or-any-other-application/</a></p>

<h3>
<a id="the-cpu-average-across-my-load-balanced-targets-is-higher-than-the-source" class="anchor" href="#the-cpu-average-across-my-load-balanced-targets-is-higher-than-the-source" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The CPU average across my load-balanced targets is higher than the source</h3>

<p>If you are replaying traffic from multiple listeners to a load-balanced target and you use sticky sessions, you may observe that the target servers have a higher CPU load than the listener servers. This may be because the sticky session cookie of the original load balancer is not honored by the target load balancer thus resulting in requests that would normally hit the same target server hitting different servers on the backend thus reducing some caching benefits gained via the load balancing.  Try running just one listener against one replay target and see if the CPU utilization comparison is more accurate.</p>

<h2>
<a id="tuning" class="anchor" href="#tuning" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Tuning</h2>

<p>To achieve the top most performance you should tune the source server system limits:</p>

<pre><code>net.ipv4.tcp_max_tw_buckets = 65536
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_tw_reuse = 0
net.ipv4.tcp_max_syn_backlog = 131072
net.ipv4.tcp_syn_retries = 3
net.ipv4.tcp_synack_retries = 3
net.ipv4.tcp_retries1 = 3
net.ipv4.tcp_retries2 = 8
net.ipv4.tcp_rmem = 16384 174760 349520
net.ipv4.tcp_wmem = 16384 131072 262144
net.ipv4.tcp_mem = 262144 524288 1048576
net.ipv4.tcp_max_orphans = 65536
net.ipv4.tcp_fin_timeout = 10
net.ipv4.tcp_low_latency = 1
net.ipv4.tcp_syncookies = 0
</code></pre>

<h2>
<a id="contributing" class="anchor" href="#contributing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contributing</h2>

<ol>
<li>Fork it</li>
<li>Create your feature branch (git checkout -b my-new-feature)</li>
<li>Commit your changes (git commit -am 'Added some feature')</li>
<li>Push to the branch (git push origin my-new-feature)</li>
<li>Create new Pull Request</li>
</ol>

<h2>
<a id="companies-using-gor" class="anchor" href="#companies-using-gor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Companies using Gor</h2>

<ul>
<li>
<a href="https://www.gov.uk">GOV.UK</a> - UK Government Digital Service</li>
<li>
<a href="http://theguardian.com">theguardian.com</a> - Most popular online newspaper in the UK</li>
<li>
<a href="http://www.tomtom.com/">TomTom</a> - Global leader in navigation, traffic and map products, GPS Sport Watches and fleet management solutions.</li>
<li>
<a href="http://www.3scale.net/">3SCALE</a> - API infrastructure to manage your APIs for internal or external users</li>
<li>
<a href="http://www.opinionlab.com">Optionlab</a> - Optimize customer experience and drive engagement across multiple channels</li>
<li>
<a href="http://tubemogul.com">TubeMogul</a> - Software for Brand Advertising</li>
<li>
<a href="http://www.videologygroup.com/">Videology</a> - Video advertising platform</li>
<li>
<a href="http://foreksmobile.com/">ForeksMobile</a> -  One of the leading financial application development company in Turkey</li>
<li>
<a href="http://granify.com">Granify</a> - AI backed SaaS solution that enables online retailers to maximise their sales</li>
<li>And many more!</li>
</ul>

<p>If you are using Gor we are happy add you to the list and share your story, just write to: <a href="mailto:leonsbox@gmail.com">leonsbox@gmail.com</a></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/buger/gor">Gor</a> is maintained by <a href="https://github.com/buger">buger</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
